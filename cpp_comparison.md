# Сравнение стандартов C++. Почему важно переходить на новые стандарты

Базовая статья [The Key Differences Between C++14, C++17, and C++20](https://www.geeksforgeeks.org/cpp14-vs-cpp17-vs-cpp20/)

## C++11 - фундаментально важный стандарт языка:

- автоматические циклы for
- умные указатели (unique_ptr, shared_ptr, weak_ptr)
- лямбда-выражения
- шаблоны (templates)
- списки инициализации
- улучшенная поддержка многопоточности

## C++14 - улучшенное выведение типов:

- Relaxation of constexpr Restrictions - улучшенная поддержка constexp с ослабленными ограничениями
- двоичные литералы. Пример: `int binaryNumber = 0b1010;`
- Generic lambdas (универсальные лямбды)
- шаблоны переменных
- Automatic Return Type Deduction for Functions

**Generic lambdas** обеспечивает выведение типов для случаев использования лямбда-функций. Например:

```cpp
auto sum = [](auto a, auto b) { return a + b; };
```

Автоматическое выведение возвращаемых значений функций, позволяет, в частности, снизить сложность рефакторинга при изменении требований к типам. Пример кода:

```cpp
auto add(int a, int b) {
    return a + b; // Компилятор выведени тип возвращаего значения как int
}
```

>Мне очень понравилась эта возможность в Rust.

## C++17 - повышение производительности программистов:

- Inline Variables - теперь можно инициализировать переменные в заголовочных файлах. Например: `inline int x = 10;`
- Structured Bindings (структурированные привязки)
- std::optional
- std::variant
- параллельные алгоритмы
- Сonditional execution during compile time - условные операторы на этапе компиляции. См.: `if constexpr (sizeof(T) <= 4) {`
- Fold Expressions - улучшения в части **variadic template arguments**

Параллельные алгоритмы могут кратно повышать производительность таких операций, как поиск и сортировка на многоядерных процессорах.

std::variant - по сути, имитация динамических типов.

>В ПроАТМ используется собственный "велосипед" в подсистеме генерации клиентских чеков и формировании записей журнала аудита

Structured Bindings - это конструкция, похожая не destructuring в JavaScript:

```cpp
std::tuple<int, std::string> data{42, "hello"};
auto [number, message] = data;
```

Пример использования Fold Expressions:

```cpp
template<typename... Args>
auto sum(Args... args) {
    return (args + ...);
}
```

## C++20 - значительное повышение эффективности кода:

- Concepts - концепции. Позволяют определять ограничения типов для шаблонного кода. См.: `concept Integral = std::is_integral_v<T>;`
- The Ranges Library (диапазоны) - позволяет эффективно выполнять такие трансформации операции, как filter, map, и т.д. Имеет схожесть с JavaScript
- std::span
- сопрограммы
- трехстороннее сравнение
- Модули - существенно более эффективный способ управления зависимостями, чем традиционные заголовочные файлы
- Coroutines (корутины)

The Ranges Library и std::span() - позволяют значительно уменьшить количество операций выделения памяти, без снижения лаконичности кода. Может сильно влиять на производительность кода.

Корутины позволяют разрабатывать асинхронный код (точнее - асинхронные функции, которые могут использовать потребители):

```cpp
generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        std::tie(a, b) = std::make_tuple(b, a + b);
    }
}
```

Ключевые слова: co_yield и co_await.
