# Проверка уникальности случайных чисел в EMV-ядре

Проведение платёжных операций с использованием банковских карт часто требует применения EMV-ядра, задачей которого является обеспечение защиты от злоумышленноков, посредством криптографических алгоритмов. При формировании транзакционного запроса (запроса на перемещение денежных средств), EMV-чип обсуществляет вычисление электронной подписи и передаёт её терминалу, который, в совю очередь, пересылает её вместе с фактическими реквизитами операции на хост фронтальной системы банка. Хост использует эту цифровую подпись, а также дополнительные поля для того, чтобы удостовериться, что данные не были изменены в процессе доставки финансового запроса от терминала, обслужившего клиента и до банка. Использование криптопроцессора в EMV-чипе, а также криптоключей не доступных для чтения с карты, обеспечиватся высокий уровнень защиты держателей карт от действий злоумышленников.

Одной из ключевых функций в обеспечении защиты является генерация **случайного числа**, которое подмешивается к данным во время обмена данными и гарантирует, что перехват злоумышленниками данных не создаст дополнительных уязвимостей в протоколе.

При прохождении сертификации реализации EMV-ядра в EMVCo, тест 2CC.145.00.00 проверяет качество генерации чисел. Тест проверяет как алгоритм распределения значений, так и факты генерации повторных значений в выборке из 1000 чисел.

Чтобы гарантировать уникальность сгенерированных чисел, в ПроАТМ используется дополнительный компонент - **UniqueRandomNumbersChecker**. Этот компонент сохраняет ранее сгенерированные номера (в циклическом буфере) и при генерации нового числа проверяет совпадения.

## Разные варианты решения задачи

В первоначальном варианте, сгенерированные числа сохранялсь в базе данных SQLite. Для быстрого поиска чисел в базе использовались индексы базы данных. Каждая запись в базу требовала переиндексации. Со временем, размер базы данных вырастал, что требовало удаления старых записей, а так же применения команды vacuum - удаления из файла мусора, оставшегося от удаления записей. Механизм не эффективно использовал ограниченные вычислительные ресурсы терминала, содержал много избыточного кода и приводил к возникновению различных негативных side-effect-ов.

Второй вариант реализации прикреплён к данному репозитарию. В этом варианте используется циклический буфер, сохраняемый в файл на жёстком диске. Недостаток решения - операция ввода/вывода есть и для каждой платёжной операции требуется перезаписывать файл размером около 20 Кб.

## Что требуется сделать?

Необходимо разработать Unit-тесты для проверки корректности реализации класса **uniqueRnd**.

Алгоритм второго поколения также может быть не оценен, как не оптимальный. Одним из направлений улучшения работы алгоритма может быть уменьшение количества времени, занимаемого операциями ввода/вывода. Например, в файл на жёстком диске можно сохранять не циклический буфер, а seed (начальное значение генератора случайных чисел) и count (выполненное количество генераций). Запись может вестись не в режиме "перепись", а в режиме "дозаписи".

Вместе с тем, без чётких метрик утверждения об эффективности того, или иного алгоритма, являются просто упражнениями в риторике. По этой причине, в рамках задачи, рекомендуется сформировать критерии эффективности алгоритма, выполнить сбор метрик (например, используя Google Benchmark) и сравнить разные версии между собой.

Оптимальным результатом работы будет являться реализация кода и отчёт, подтверждающий его превосходство над альтернативными посредством экспериментально собранных метрик (и, желательно, теоретических выкладок).

## Подсказки по использованию Boost

Стандартная папка **Boost** в Windows размещается на диске `c:` и называется `c:\boost`. В папке находятся две подпапки - `lib` со библиотеками различных версий boost, в которых конкретная версия Boost включена в имя каждого файла. В подпапке `include` находятся подпапки с именами конкретных версий Boost, например: "boost-1_76". Таким образом достигается возможность использования на одной машине различных версий Boost одновременно.

Для того, чтобы CMake при запуске из под Windows 7 смог найти компоненты Boost, необходимо установить переменную окружения **BOOST_ROOT** в значение "c:/boost".

## Генерация скрипта сборки с помощью CMake

В папке с файлом "CMakeLists.txt" следует выполнить следующие команды:

```
mkdir build
cd build
cmake ..
```

В результате выполнения в папке "build" будет создан файл "random-number.sln", который можно использовать для компиляции приложения в IDE Visual Studio.

## Выполнение UNIT-тестов

Для добавления тестовых последовательностей в файл "CMakeLists.txt" следует включить дополнительные команды:

```cmake
project(random-number LANGUAGES CXX)
...
enable_testing()

add_test(
	NAME main_test
		COMMAND $<TARGET_FILE:test-random>
	)
```

После сборки проекта можно запустить тесты на исполнение:

```
ctest -C Debug
```

Параметр -C позволяет указать конфигурацию выполняемых тестов. В соответствии с [официальной документацией](https://cmake.org/cmake/help/v2.8.12/ctest.html#opt:-Ccfg--build-configcfg):

```
-C <cfg>, --build-config <cfg>: Choose configuration to test.

Some CMake-generated build trees can have multiple build configurations in the same tree. This option can be used to specify which one should be tested. Example configurations are "Debug" and "Release".
```