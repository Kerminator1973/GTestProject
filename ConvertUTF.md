# Цели преобразования текстовых строк в приложении

Современные приложения довольно часть осуществляют взаимодействие с другими системами. В каких-то случаях такое взаимодействие осуществляется через сетевое соединение, в каких-то используется подключаемые библиотеки. При этом кодировки передаваемых текстовых данных могут быть принципиально разными. Так, например, приложение должно запросить у интеграционного сервиса (web API) список назначений платежа и сервис возвращает текстовые названия в кодировке UTF16 (двух байтовая). После выбора назначения платежа пользователем, приложением должно передать информацию о конкретном назначени платежа в ядру платёжной системы, которое работает в кодировке CodePage1251 (одно байтовая).

При ответственном подходе, приложение использует только одну кодировку текстовых значений в своих собственных компонентах, а при взаимодействии с другими компонентами осуществляет перекодирование в/из формат(а) целевого компонента. Таким образом, преобразование текста осуществляется только на "границах" системы, что позволяет избежать ошибок отсутствия должны кодировок, или лишних многогратных перекодировок текста.

Перед началом разработки кода программист должен принять решение о кодировке, принятой в самом приложении. Например, в ПроАТМ такой кодировкой является UTF8.

Вспомогательная библиотека ConvertUTF используется для того, чтобы обеспечить перекодирование форматов текста на границе между внутренними компонентами ПроАТМ и внешними компонентами.

## Что имеет смысл тестировать

Основная функция библиотеки конвертация текстов. В общем случае, конвертация может сбоить в тех случаех, когда происходит потеря информации о языке, закодированном в текстовой строке. Типовые тесты:

- Входная строка является UTF16 и содержит кириллические символы. Текущая **locale** - символы русского языка. Выходная строка - CodePage1251
- Входная строка является UTF16 и содержит как китайские иероглифы, так и текст на иврите. Кодировка должна осуществляться в UTF8, а затем из UTF8 в UTF16. После двойного преобразования, оригинальная и преобразованная строка должны быть эквивалентными
- Используя подход "буфер внутри буфера" добавить во внешнем буфере "маркеры неизменности" (например, байты с кодом 0xCC) выполнить типовые операции преобразования двух байтовых последовательностей в одно байтовые и обратно. "Маркеры неизменности" должны оставаться без изменений

## Вопросы быстродействия

Для достижения максимально эффективного использования вычислительных ресурсов следует обратить внимание на следующие вопросы:

- В какой кодировке эффективнее всего осуществляется поиск символа/строки (предположительно, в UTF8 поиск должен быть самым медленным)?
- Какая кодировка занимает минимальный объём памяти (ОЗУ)?
- Какие преобразования являются наиболее медленными?
- Как выделение дополнительных буферов для результатов кодирования влияет на производительность?
- Можно ли использовать буфера для преобразования повторно?

## Подводные камни

- конкретные компиляторы могут использовать собственные "договорённости" (conventions). Например, код написанный для сборки Visual Studio C++ Tools часто содержит директиву include для файла "stdafx.h", который используется для генерации предварительно скомпилированных заголовочных файлов. Другие компиляторе не требуют использования подобной директивы
- установленная locale операционной системы может отличаться на рабочем месте программиста и на сервер сборки. Например, программист может использовать русскую редакция Windows, а не сервер сборке может быть установлена английская версия. Это может приводить к тому, что преобразования текста с использованием _default locale_ будет приводить к потере информации о кодировке и кириллический текст, например, будет заменяться на знаки вопроса: ??? ?????
- различия в предоставляемых операционной системой API могут критически различаться. Так, например, многие приложения, разработанные для Windows, активно используют платформозависимую Win32 API
- в проектах Visual Studio явным образом указывается Character Set проекта: "Use Multi-Byte Character Set", или "Use Unicode Character Set". От этого параметра зависит, какой набор библиотек будет использовать компилятор при сборке приложения. Чтобы обеспечить совместимость с обоими вариантами библиотек, при работе со строками следует преименять вызовы функций wrapper-ов

## Платформозависимость. Преобразование из UTF-8 в cp1251 и обратно

Тестируемый компонент ConvertUTF использует вызовы Win32: MultiByteToWideChar() и WideCharToMultiByte(). Эти вызовы не являются платформонезависимыми. В данном случае, одно из ключевых требований к Unit-тестам не может быть выполнено. Чтобы решить проблему, может потребоваться переработка компонента ConvertUTF. Предложение переработки тестируемого компонента, обычно должно быть подкреплено предложением технического решения.

Одним из потенциальных решений может быть использование библиотеки locale из состава Boost. Чтобы предложение по переработке было конкретным, следует выполнить сравнение производительности существующего и предлагаемого решения, которое может быть выполнено с помощью Google Benchmark. Ключевыми вопросами при портировании решения могут являться:

- Ухудшается ли произодительность в базовой операционной системе (Windows)
- Нужно ли/можно ли оптимизировать процедуру инициализации

Чтобы преобразовать текст из UTF-8 в Windows-1251, может быть использован следующий код:

```cpp
#include <iostream>
#include <boost/locale.hpp>

int main()
{
    // Вводим данные в текущей locale - это должно быть UTF8
    std::string temp;
    std::cin >> temp;

    boost::locale::generator generator;
    std::locale locale = generator.generate("ru-RU.CP1251");

    std::string s = boost::locale::conv::from_utf(temp, locale);
    std::cout << s << std::endl;
}
```

Преобразовать из cp1251 в UTF-8 можно используя функцию boost::locale::conv::**to_utf()**.
