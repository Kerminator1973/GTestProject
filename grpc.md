# Использование gRPC

gRPC применяется чаще всего как инструмент взаимодействия между микросервисами в соответсвующей архитектуре. gRPC часто противопоставляют JSON.

Недостатки JSON:

- динамическая схема, т.е. структура документа может меняться произвольным образом
- parsing документа медленный
- отсутствие типизации
- относительно большой размер данных

Protobuf, являющийся одним из уровней gRPC пытается компенсировать эти недостатки, включая строгую схему данных.

Ориентировочно, пакет protobuf в четыре раза меньше, чем JSON.

## Типы данных Protobuf

Основные типы данных Protobuf:

- double/float
- int32/int64
- uint32/uint64
- sint32/sint64 - оптимизация для преимущественно отрицательных чисел
- fixed32/fixed64 - оптимизация для больших чисел, с большим количеством нулей в конце (10 в степени N)
- bool, string, bytes
- google nullable type - особый тип, который может быть nullable

Так же при определении типа может использоваться модификатор repeated, который означает динамический массив. Для понимания: list, vector, slice.

Пример сообщения:

```grpc
message InfoResponse {
    int32 id = 1;
    int32 moderator_id = 2;
    repeated int64 task_ids = 3;
}
```

Числа с правой части определения - это порядковый номер поля в сообщении.

Сообщения могут быть вложенными:

```grpc
message CreateNoteRequest {
    NoteContent content = 1;
}
```

В определении сообщений могут быть использованы enum-ы:

```grpc
enum ContentType {
    POST = 1;
    COMMENT = 1;
    reserved 2 to 7;
    STREAM = 8;
}
```

Хорошей практикой является определение значения с индексом 0, например: `UNKNOWN=0`.

Ключевое слово reserved позволяет обеспечивать обратную совместимость - добавлять новые поля, не разрушая совместимости с уже существующим кодом.

По структуре protobuf похож на TLV, но он чуть похитрее - в нём явно передаются тип и порядковый номер поля.

## Генерация кода

Работа начинается с декларации. Пример декларации:

```grpc
syntax = "proto3";

package example;

// Пользовательская информация
message User {
  // Уникальный идентификатор пользователя
  int64 id = 1;

  // Имя пользователя
  string name = 2;

  // Электронная почта (опционально)
  string email = 3;

  // Список ролей пользователя
  repeated Role roles = 4;
}

// Возможные роли пользователя
enum Role {
  UNKNOWN = 0;
  ADMIN   = 1;
  EDITOR  = 2;
  VIEWER  = 3;
}

// Запрос на получение пользователя по ID
message GetUserRequest {
  int64 user_id = 1;
}

// Ответ с данными пользователя
message GetUserResponse {
  User user = 1;
}

// Сервис, предоставляющий операции над пользователями
service UserService {
  // Получить информацию о пользователе
  rpc GetUser (GetUserRequest) returns (GetUserResponse);
}
```

После того, как осуществлена разработка декларации осуществляется генерация кода для клиента и сервера, для конкретных языков программирования. Google поддерживает генерацию для нескольких основных языков, включая: Java, Go и C++. Существуют custom-ные генераторы для других языков программирования.

Основной модуль генерации кода protobuf называется **protoc**, но для своей работы он может требовать и другие исполняемый файлы, для генерации кода на целевых языках программирования.

Часто для генерации используют make-файл, который описывает вызов protoc (с параметрами), копирование результатов генерации в целевые папки и удаление артефактов генерации.

Хорошей структурой папок для хранения деклараций (proto) является папка "api", внутри которой описываются декларации для конкретных API, например - "user_v1".
