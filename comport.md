# Управление аппаратными узлами посредством COM-порта

Управление узлами через COM-порт является одной из наиболее критичных задач для управляющего ПО устройствами банковского самообслуживания. Не смотря на кажущуюся простоту задачи, с ней связано большое количество "подводных камней" и инженерных вызовов.

Принимая технические решения, следует принять во внимание ответы на такие вопросы как:

-	Планируется ли использовать библиотеки работы с COM-портом для разработки приложений для разных операционных систем (Linux, Windows)?
-	Будут ли команды к устройству отправляться из разных потоков исполнения (см. multi-threading)?
-	Будут ли использоваться разные типы запросов, например: отправка команды на исполнение и систематический опрос состояния устройства. Если ответ "будут", то каким образом следует прерывать систематический опрос состояния устройств для отправки команд?
- Должен ли API класса работы с устройством через COM-порт быть асинхронным для прикладного программиста?
-	Можно ли использовать низкоуровневый код, или следует создать переносимый, высокоуровневый код?
-	Какие образом будет осуществляться борьбя с зависаниями: устройства, драйвера порта?

Принимая во внимание опыт специалистов КБ ДОРС при разработке кода взаимодействия с узлами через COM-порт, можно говорить о том, что используется следующие подходы:

- для записи и чтения в порт используются функции файлового ввода/вывода. Для Windows: CreateFile(), CloseHandle(), WriteFile(), ReadFile(). Для Linux: open(), close(), read(), write()
- для настройки порта используется API конкретной операционной системы. Для Windows: структуры DCB и COMSTAT, функции: GetCommState(), SetCommState(), GetOverlappedResult(), SetCommTimeouts(), CancelIo(). Для Linux может использоваться библиотека **termios**
- часто используется многопоточная модель, в которой есть отдельный поток polling-а устройства с целью кэширования актуального состояния узла. Для выполнения команды используется второй поток. Коммуникационный порт является разделяемым ресурсом, доступ к которому организуется посредством объектов синхронизации операционной системы (чаще всего - mutex)
- в потоке polling-а может использоваться фильтрация данных, например, могут извлекаться и анализироваться логи работы устройства

Инженерный подход предполагает, что, с одной стороны, ранее успешно использованые подходы следует продолжать применять, но с другой стороны, должны быть чётко сформулированы "критерии успешности". К таким критериям следует отнести:

- Простоту прикладного кода
- Простоту реализации библиотеки для управления узлом посредством COM-порта
- Эффективное использование вычислительных ресурсов процессора и памяти
- Обеспечение минимальных временных потерь на выполнение обмена данными
- Гибкость решения

Часть критериев успешности можно оценивать как субъективные, но временные потери и расход вычислительных ресурсов можно измерить используя Google Benchmark. Целью данного тестового задания является экспериментальная проверка следующих утверждений:

- Расход вычислительных ресурсов при использовании высокоуровневых, переносимых библиотек (например, Boost.Asio) близок к расходу при использовании низкоуровневых вызовов API
- Асинхронный, однопочный код библиотеки управления узлом работает кратно более эфффективно, чем многопоточный код

Бонусная часть задачи - реализация способов решить проблему с зависанием устройства/драйвера COM-порта.

# Анти-паттерны (по результатам тестовых решений задач)

При анализе выполненных контрибьюторами тестовых задач был выявлен ряд **анти-паттернов**, которые рекомендуется принимать во внимание при разработке кода.

Интуитивно, более простое решение кажется более правильным и это является причиной того, что некоторые разработчики решили не использовать событийную модель для межтопочного взаимодействия, предпочитая синхронизацию через переменную, проверяюмую через некоторый период времени. Исключительно негативный вариант - синхронизация через статическую переменную без модификатора **volitile**.

volatile — информирует компилятор о том, что значение переменной может меняться и следует применять регистровую оптимизацию, т.е. хранить ей в регистре процессора, а не в оперативной памяти.

Синхронизация через переменную приводит к бесполезным потерям ресурсов и не вынужденным задержкам в работе кода.

Разрабатывая программный код либо минимизируйте использование многопоточности, либо используйте событийную модель для межпоточного взаимодействия.

Рекомендуются для прочтения статья [Потоки, блокировки и условные переменные в C++11](https://habr.com/ru/post/182610/) и её [вторая часть](https://habr.com/ru/post/182626/). Под событийной моделью подразумевается использование **condition_variable** и методы **notify_one**() и **notify_all**().

# Представленные решения и выводы

В [данном решении](https://github.com/Muzantip/CommPortTest/tree/master) осуществляется проверка производительности трёх подходов:

- низкоуровневый однопоточный
- однопоточный с использованием асинхронного кода Boost.Asio
- многопоточный с использованием событийной модели
