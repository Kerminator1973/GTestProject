# Использование gRPC

gRPC применяется чаще всего как инструмент взаимодействия между микросервисами в соответсвующей архитектуре. gRPC часто противопоставляют JSON.

Недостатки JSON:

- динамическая схема, т.е. структура документа может меняться произвольным образом
- parsing документа медленный
- отсутствие типизации
- относительно большой размер данных

Protobuf, являющийся одним из уровней gRPC пытается компенсировать эти недостатки, включая строгую схему данных.

Ориентировочно, пакет protobuf в четыре раза меньше, чем JSON.

## Типы данных Protobuf

Основные типы данных Protobuf:

- double/float
- int32/int64
- uint32/uint64
- sint32/sint64 - оптимизация для преимущественно отрицательных чисел
- fixed32/fixed64 - оптимизация для больших чисел, с большим количеством нулей в конце (10 в степени N)
- bool, string, bytes
- google nullable type - особый тип, который может быть nullable

Так же при определении типа может использоваться модификатор repeated, который означает динамический массив. Для понимания: list, vector, slice.

Пример сообщения:

```proto
message InfoResponse {
    int32 id = 1;
    int32 moderator_id = 2;
    repeated int64 task_ids = 3;
}
```

Числа с правой части определения - это порядковый номер поля в сообщении.

Сообщения могут быть вложенными:

```proto
message CreateNoteRequest {
    NoteContent content = 1;
}
```

В определении сообщений могут быть использованы enum-ы:

```proto
enum ContentType {
    POST = 1;
    COMMENT = 1;
    reserved 2 to 7;
    STREAM = 8;
}
```

Хорошей практикой является определение значения с индексом 0, например: `UNKNOWN=0`.

Ключевое слово reserved позволяет обеспечивать обратную совместимость - добавлять новые поля, не разрушая совместимости с уже существующим кодом.

По структуре protobuf похож на TLV, но он чуть похитрее - в нём явно передаются тип и порядковый номер поля.

## Генерация кода

Работа начинается с декларации. Пример декларации:

```proto
syntax = "proto3";

package example;

// Пользовательская информация
message User {
  // Уникальный идентификатор пользователя
  int64 id = 1;

  // Имя пользователя
  string name = 2;

  // Электронная почта (опционально)
  string email = 3;

  // Список ролей пользователя
  repeated Role roles = 4;
}

// Возможные роли пользователя
enum Role {
  UNKNOWN = 0;
  ADMIN   = 1;
  EDITOR  = 2;
  VIEWER  = 3;
}

// Запрос на получение пользователя по ID
message GetUserRequest {
  int64 user_id = 1;
}

// Ответ с данными пользователя
message GetUserResponse {
  User user = 1;
}

// Сервис, предоставляющий операции над пользователями
service UserService {
  // Получить информацию о пользователе
  rpc GetUser (GetUserRequest) returns (GetUserResponse);
}
```

После того, как осуществлена разработка декларации осуществляется генерация кода для клиента и сервера, для конкретных языков программирования. Google поддерживает генерацию для нескольких основных языков, включая: Java, Go и C++. Существуют custom-ные генераторы для других языков программирования.

Основной модуль генерации кода protobuf называется **protoc**, но для своей работы он может требовать и другие исполняемый файлы, для генерации кода на целевых языках программирования.

Часто для генерации используют make-файл, который описывает вызов protoc (с параметрами), копирование результатов генерации в целевые папки и удаление артефактов генерации.

Хорошей структурой папок для хранения деклараций (proto) является папка "api", внутри которой описываются декларации для конкретных API, например - "user_v1".

## Чем хорош gRPC

В качестве надостатков Http обычно рассматривают:

- Для каждого нового запроса создаётся новое соединение (медленно и дорого)
- Head of Blocking (слабое распараллеливание запросов)
- Не сжимает заголовки (они могут быть большими)
- Нет встроенных механизмов server push (однако есть расширенные механизмы: WebSockets, SSE)

>Важно заметить, что в определённом смысле "картинка" Http упрощена. Так, например, в Go можно было бы использовать WebSockets, но имеющаяся реализация - устаревшая, базирующаяст на socket.io (возможно, порт с JavaScript). Т.е. в рамках эко-системы Google удобнее использовать именно gRPC, а не, например, WebSockets

gRPC решает указанные выше проблемы Http, используя "под капотом" HTTP/2.

## Как осуществляется генерация кода

В рамках gRPC различаются API клиента и сервера. Одним вызовом make, обычно, выполняется генерация и клиента, и сервера для одного языка программирования.

Утилита protoc генерирует код в двух режимах: только структуры (generate-structs) и структуры + stub-ы для кода (generate).

Чтобы protoc сгенерировал stub-ы для кода, необходимо в файле-декларации (proto) описать сервис, например:

```grpc
service UserService {
  // Получить информацию о пользователе
  rpc GetUser (GetUserRequest) returns (GetUserResponse);
}
```

По договорённостям gRPC, сервисная функция имеет один вход (структуру) и один выход (структуру).

## Postman

В актуальных версиях Postman есть поддержка gRPC. Нужно выбрать в главном меню **new** -> gRPC, указать Endpoint (например, `localhost:50501`) и Postman предложит обратиться к серверу и запросить у него список доступных функций. Выбрав функцию из полученного списка можно попросить Postman сгенерировать пример запроса. Далее можно выполнить запрос и он, с высокой вероятностью, корректно выполнится.

Удобство подхода состоит в том, что можно сначала разработать только сервер, а когда станет ясно, что он успешно разработан, то тогда уже можно будет потратить время и на клиента.
