# Сравнение стандартов C++. Почему важно переходить на новые стандарты

Базовая статья [The Key Differences Between C++14, C++17, and C++20](https://www.geeksforgeeks.org/cpp14-vs-cpp17-vs-cpp20/)

Дополнительные статьи:

- [Краткий обзор нововведений C++23: deducing this](https://habr.com/ru/articles/722668/)
- [C++23 — финал, C++26 — начало](https://habr.com/ru/companies/yandex/articles/715358/)

## C++11 - фундаментально важный стандарт языка:

- автоматические циклы for
- умные указатели (unique_ptr, shared_ptr, weak_ptr)
- лямбда-выражения
- шаблоны (templates)
- списки инициализации
- улучшенная поддержка многопоточности

## C++14 - улучшенное выведение типов:

- Relaxation of constexpr Restrictions - улучшенная поддержка constexp с ослабленными ограничениями
- двоичные литералы. Пример: `int binaryNumber = 0b1010;`
- Generic lambdas (универсальные лямбды)
- шаблоны переменных
- Automatic Return Type Deduction for Functions

**Generic lambdas** обеспечивает выведение типов для случаев использования лямбда-функций. Например:

```cpp
auto sum = [](auto a, auto b) { return a + b; };
```

Автоматическое выведение возвращаемых значений функций, позволяет, в частности, снизить сложность рефакторинга при изменении требований к типам. Пример кода:

```cpp
auto add(int a, int b) {
    return a + b; // Компилятор выведени тип возвращаего значения как int
}
```

>Мне очень понравилась эта возможность в Rust.

## C++17 - повышение производительности программистов:

- Inline Variables - теперь можно инициализировать переменные в заголовочных файлах. Например: `inline int x = 10;`
- Structured Bindings (структурированные привязки)
- std::optional
- std::variant
- параллельные алгоритмы
- Сonditional execution during compile time - условные операторы на этапе компиляции. См.: `if constexpr (sizeof(T) <= 4) {`
- Fold Expressions - улучшения в части **variadic template arguments**

Параллельные алгоритмы могут кратно повышать производительность таких операций, как поиск и сортировка на многоядерных процессорах.

std::variant - по сути, имитация динамических типов.

>В ПроАТМ используется собственный "велосипед" в подсистеме генерации клиентских чеков и формировании записей журнала аудита

Structured Bindings - это конструкция, похожая не destructuring в JavaScript:

```cpp
std::tuple<int, std::string> data{42, "hello"};
auto [number, message] = data;
```

Пример использования Fold Expressions:

```cpp
template<typename... Args>
auto sum(Args... args) {
    return (args + ...);
}
```

## C++20 - значительное повышение эффективности кода:

- Concepts - концепции. Позволяют определять ограничения типов для шаблонного кода. См.: `concept Integral = std::is_integral_v<T>;`
- The Ranges Library (диапазоны) - позволяет эффективно выполнять такие трансформации операции, как filter, map, и т.д. Имеет схожесть с JavaScript
- std::span
- сопрограммы
- трехстороннее сравнение
- Модули - существенно более эффективный способ управления зависимостями, чем традиционные заголовочные файлы
- Coroutines (корутины)

The Ranges Library и std::span() - позволяют значительно уменьшить количество операций выделения памяти, без снижения лаконичности кода. Может сильно влиять на производительность кода.

Корутины позволяют разрабатывать асинхронный код (точнее - асинхронные функции, которые могут использовать потребители):

```cpp
generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        std::tie(a, b) = std::make_tuple(b, a + b);
    }
}
```

Ключевые слова: co_yield и co_await.

## C++23

- Замена перегрузок &, const&, &&, const&& одной конструкцией
- Замена CRTP (Curiously Recuring Template Pattern) на более вменяемую конструкцию
- Рекурсивные лямбды
- std::print()
- std::expected

## C++26

- Улучшение читаемости кода с использованием std::tuple и std::pair посредством std::get и std::tuple_size
- `#embed` - портирование многих новых feature из нового стандарта Си в C++
- Получение std::stacktrace из исключений
- Stackful-корутины

## Различия в версиях библиотеки Boost.org

Различные версии библиотеки Boost ориентировались на разные версии стандарта C++. Можно условно разделить связь между Boost и стандартом C++ на эры:

- The Pre-C++11 Era (C++98/03) - версии Boost до ~1.55
- The C++11 Revolution - версии Boost от ~1.56 до ~1.65. Активное использование move-семантики, variadic templates и constexpr. Как результат, код стал более производительным и более понятным. Появились новые библиотеки, такие как Boost.Hana (метапрограммирование) и Boost.Beast (HTTP/WebSocket library построенная на Asio)
- The C++14 / C++17 Maturity Era - версии Boost от ~1.66 до ~1.79. Появились новые комплексные библиотеки, такие как Boost.Graph, Boost.Interprocess и Boost.Python
- The Modern C++20 / C++23 Era - версии Boost от 1.80 и выше. Большая часть библиотек может быть собрана компиляторами С++17, некоторые - C++14. Новейшие библиотеки требуют использования C++20. В Boost.Asio происходит переход на coroutines. Поддержка новых библиотек, например: numerics (Boost.Multiprecision). Библиотеки для сетевого взаимодействия Boost.Asio и Boost.Beast переводятся на std::net

Для каждой версии библиотеки Boost необходимо прочитать требования по сборке, в которой указан минимально допустимый компилятор.

Некоторые библиотеки из состава Boost могут быть собраны разными компиляторами, для чего следует использовать флаг cxxstd при сборке, например:

```shell
./b2 cxxstd=11`
```
