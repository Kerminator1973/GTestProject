# Цели преобразования текстовых строк в приложении

Современные приложения довольно часть осуществляют взаимодействие с другими системами. В каких-то случаях такое взаимодействие осуществляется через сетевое соединение, в каких-то используется подключаемые библиотеки. При этом кодировки передаваемых текстовых данных могут быть принципиально разными. Так, например, приложение должно запросить у интеграционного сервиса (web API) список назначений платежа и сервис возвращает текстовые названия в кодировке UTF16 (двух байтовая). После выбора назначения платежа пользователем, приложением должно передать информацию о конкретном назначени платежа в ядру платёжной системы, которое работает в кодировке CodePage1251 (одно байтовая).

При ответственном подходе, приложение использует только одну кодировку текстовых значений в своих собственных компонентах, а при взаимодействии с другими компонентами осуществляет перекодирование в/из формат(а) целевого компонента. Таким образом, преобразование текста осуществляется только на "границах" системы, что позволяет избежать ошибок отсутствия должны кодировок, или лишних многогратных перекодировок текста.

Перед началом разработки кода программист должен принять решение о кодировке, принятой в самом приложении. Например, в ПроАТМ такой кодировкой является UTF8.

Вспомогательная библиотека ConvertUTF используется для того, чтобы обеспечить перекодирование форматов текста на границе между внутренними компонентами ПроАТМ и внешними компонентами.

## Что имеет смысл тестировать

Основная функция библиотеки конвертация текстов. В общем случае, конвертация может сбоить в тех случаех, когда происходит потеря информации о языке, закодированном в текстовой строке. Типовые тесты:

- Входная строка является UTF16 и содержит кириллические символы. Текущая **locale** - символы русского языка. Выходная строка - CodePage1251
- Входная строка является UTF16 и содержит как китайские иероглифы, так и текст на иврите. Кодировка должна осуществляться в UTF8, а затем из UTF8 в UTF16. После двойного преобразования, оригинальная и преобразованная строка должны быть эквивалентными
- Используя подход "буфер внутри буфера" добавить во внешнем буфере "маркеры неизменности" (например, байты с кодом 0xCC) выполнить типовые операции преобразования двух байтовых последовательностей в одно байтовые и обратно. "Маркеры неизменности" должны оставаться без изменений

## Вопросы быстродействия

Для достижения максимально эффективного использования вычислительных ресурсов следует обратить внимание на следующие вопросы:

- В какой кодировке эффективнее всего осуществляется поиск символа/строки (предположительно, в UTF8 поиск должен быть самым медленным)?
- Какая кодировка занимает минимальный объём памяти (ОЗУ)?
- Какие преобразования являются наиболее медленными?
- Как выделение дополнительных буферов для результатов кодирования влияет на производительность?
- Можно ли использовать буфера для преобразования повторно?

## С чего начать?

Ключевым фактором успеха в разработке программного обеспечения является движение от простого к сложному. **Кривая обучения** и **кривая сложности** задач должны быть линейным.

Работая с различными кодировками, начать можно с вывода текстовой строки в национальной кодировке в консоль: https://gist.github.com/Kerminator1973/02d852ce2192ea214c515f8b6490f18d

Собрать файл с исходными текстами компилятором gcc (под Linux) можно командой:

```
g++ imbue.cpp -o imbue
```

При выполнении кода может возникнуть исключение в том случае, если в Linux не установлен соответствующий пакет локализации. Ошибка может выглядеть следующим образом:

```
terminate called after throwing an instance of 'std::runtime_error'
  what():  locale::facet::_S_create_c_locale name not valid
```

Для установки локализации на Linux системах, часто используются специализированные утилиты. Например, на RPi можно воспользоваться утилитой **raspi-config**. Кириллическая локализация называется "ru_RU.UTF-8".

Установить локализацию можно и через командную строку, например:

```
localedef -c -i ru_RU -f CP1251 ru_RU.CP1251
```

Вывести список установленных локализаций можно командой: `locale -a`. Параметры текущей локализации можно посмотреть при помощи команды: `locale`

Собрать его же компилятором из состава Visual Studio Toolset (под Windows) можно командой:

```
cl /EHsc imbue.cpp
```

Перед сборкой приложения может потребоваться установка и настройка Visual Studio Tools. После загрузки и установки набора компиляторов, следует открыть консоль операционной системы и выполнить инициализацию системы сборки. 

Выбрать подходящую строку инициализации можно нажав кнопку "Старт" -> "Visual Studio 2013" -> "Visual Studio Tools" и выбрав соответствующий скрипт. Для x86 (32-бита) используется следующая строка инициализации:

```
%comspec% /k ""C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\vcvarsall.bat"" x86
```

Настройка переменных окружения для Visual Studio 2019 для native-компилятора x64 осуществляется командой:

```
%comspec% /k "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat"
```

## Подводные камни

- конкретные компиляторы могут использовать собственные "договорённости" (conventions). Например, код написанный для сборки Visual Studio C++ Tools часто содержит директиву include для файла "stdafx.h", который используется для генерации предварительно скомпилированных заголовочных файлов. Другие компиляторе не требуют использования подобной директивы
- установленная locale операционной системы может отличаться на рабочем месте программиста и на сервер сборки. Например, программист может использовать русскую редакция Windows, а не сервер сборке может быть установлена английская версия. Это может приводить к тому, что преобразования текста с использованием _default locale_ будет приводить к потере информации о кодировке и кириллический текст, например, будет заменяться на знаки вопроса: ??? ?????
- различия в предоставляемых операционной системой API могут критически различаться. Так, например, многие приложения, разработанные для Windows, активно используют платформозависимую Win32 API
- в проектах Visual Studio явным образом указывается Character Set проекта: "Use Multi-Byte Character Set", или "Use Unicode Character Set". От этого параметра зависит, какой набор библиотек будет использовать компилятор при сборке приложения. Чтобы обеспечить совместимость с обоими вариантами библиотек, при работе со строками следует преименять вызовы функций wrapper-ов

## Платформозависимость. Преобразование из UTF-8 в cp1251 и обратно

Тестируемый компонент ConvertUTF использует вызовы Win32: MultiByteToWideChar() и WideCharToMultiByte(). Эти вызовы не являются платформонезависимыми. В данном случае, одно из ключевых требований к Unit-тестам не может быть выполнено. Чтобы решить проблему, может потребоваться переработка компонента ConvertUTF. Предложение переработки тестируемого компонента, обычно должно быть подкреплено предложением технического решения.

Одним из потенциальных решений может быть использование библиотеки locale из состава Boost. Чтобы предложение по переработке было конкретным, следует выполнить сравнение производительности существующего и предлагаемого решения, которое может быть выполнено с помощью Google Benchmark. Ключевыми вопросами при портировании решения могут являться:

- Ухудшается ли произодительность в базовой операционной системе (Windows)
- Нужно ли/можно ли оптимизировать процедуру инициализации

Чтобы преобразовать текст из UTF-8 в Windows-1251, может быть использован следующий код:

```cpp
#include <iostream>
#include <boost/locale.hpp>

int main()
{
    // Вводим данные в текущей locale - это должно быть UTF8
    std::string temp;
    std::cin >> temp;

    boost::locale::generator generator;
    std::locale locale = generator.generate("ru-RU.CP1251");

    std::string s = boost::locale::conv::from_utf(temp, locale);
    std::cout << s << std::endl;
}
```

Преобразовать из cp1251 в UTF-8 можно используя функцию boost::locale::conv::**to_utf()**.
