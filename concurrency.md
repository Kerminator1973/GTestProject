# Многопоточность в C++

В современном C++ используются разным способы организации конкурентного исполнения кода (ранее - многопоточность), в частности, могуть быть использованы классы **std::async** и **std::thread**. Однако следует заметить, что у них разное назначение и они используются в разных ситуациях.

**std::thread** реализует низко-уровневое управление потоками исполнения - он позволяет напрямую создать поток операционной системы. Однако в этом случае нужно вручную управлять жизненным циклом этого пототка, осуществлять межпоточную синхронизацию и разрабатывать механизмы взаимодействия с другими потоками.

Пример кода:

```cpp
#include <thread>

void myFunction() {
    // Код, который должен исполняться в другом потоке
}

int main() {
    std::thread t(myFunction);
    t.join(); // Ждём, когда поток завершит свою работу
    return 0;
}
```

std::async это абстракция высокого уровня, которая позволяет выполнять функции асинхронно, возвращая объект std::future, который представляет собой результат вычислений. Реализация std::async может использовать потоки, но она также предоставляет способ написать асинхронный код, который проще использовать и он более устойчивый к ошибкам.

Пример кода:

```cpp
#include <future>

int myFunction() {
    // Асинхронно выполняемый код
    return 42;
}

int main() {
    auto f = std::async(std::launch::async, myFunction);
    int result = f.get(); // Ждём, когда будет вычислен результат
    return 0;
}
```

Ключевые различия:

- Уровень абстрации
- Синхронизация: при использовании std::thread необходимо использовать мьютексы, lock-и, критические секции и другие примитивы синхронизации. Когда используется std::async, вся синхронизация реализуется внутри std::async; можно использовать std::future и std::promise для взаимодействия между потоками
- Политика запуска: std::thread запускает поток незамедлительно, а std::async позволяет указать, когда нужно запустить задачу (см. std::launch::async и std::launch::deferred)

Какой из вариантов выбрать:

- если нужно точно контролировать (fine-grained control), как работает многопоточный код, то следует использовать std::thread
- если нужен простой и устойчивый к ошибкам код и при этом не особенно важно управлять потоками, то рекомендуется использовать std::async
