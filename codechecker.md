# Code Checker - статический анализатор кода

Базовая статья - [CodeChecker: анализируем большой проект на С++ быстро, эффективно и бесплатно](https://habr.com/ru/companies/yadro/articles/838878/) by YADRO.

Официальная документация по [продукту](https://codechecker.readthedocs.io/en/latest/).

Позволяет запускать различные анализаторы кода C/C++ под Linux и macOS: Clang-Tidy, Clang Static Analyzer, Cppcheck и GCC Static Analyzer — в любой комбинации. На официальном сайте есть ссылка на 

Code Checker - это Python-пакет.

Варианты установки:

```shell
pip3 install codechecker
```

Можно установить пакет в виртуальном окружении или воспользоваться pipx, который самостоятельно создаст venv: 

```shell
pipx install CodeChecker
```

Также возможна установка через пакетный менеджер Snap:

```shell
sudo snap install codechecker --classic
```

Для передачи исходников на анализ, потребуется создать файл "compile_commands.json". Этот файл содержит _compilation database_ проекта, который используют IDE (например: VSCode, CLion), средства разработки (например: Ninja, Bazel) и анализаторы кода (например: SonarLint).

Структура файла (JSON) состоит мз массива элементов, в каждом из которых есть:

- directory: папка из которой выполняется команда
- command: команда сборки файла
- file: имя файла

Если в проекта используется CMake, то в каталоге проекта можно запустить команду:

```shell
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
```

Либо в папке `build`, используя чуть более длинную команду:

```shell
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..
```

Альтернативный вариант - использовать утилиту Bear, которая работает с clang.

Я устанавливал утилиту через snap и в моём случае она называлась `codechecker`.

Команда запуска статических анализаторов:

```shell
codechecker analyze ./compile_commands.json --enable=sensitive --output ./reports
```

В приведённой выше статье команда чуть другая:

```shell
CodeChecker analyze ./compile_commands.json --analyzers clangsa --enable=alpha --enable=sensitive --output ./reports
```

В моём случае, на машине с Ubuntu 24.04 автоматически применились анализаторы clang-tidy и clangsa.

Для того, чтобы поработать с результатами, требуется сконвертировать результаты обработки в статический web-сайт:

```shell
codechecker parse --export html --output ./reports_html ./reports
```

Однако, в моём случае, вывод был абсолютно беполезным, т.к. система былол найдено несколько тысяч замечаний к The Boost Library, а не к моему коду.

Команда `--exclude */boost/*` не была принята утилитой. Запрос `codechecker analyze --help`, к сожалению, не дал четких подсказок, как исключить из анализа the Boost library.

Однако в папке экспорта лежали файлы со сложными именами, в которых было существенно меньше замечаний к коду. И вот в этих файлах были замечания непосредственно к коду моего приложения. И пару замечаний оказались очень полезными.

Чтобы исключить файлы Boost из анализа, вероятнее всего, нужно настроить конфигурационные файлы Clang-Tidy (.clang-tidy) и Clang Static Analyzer (clangsa).

Однако когда все файлы из подкаталога "build" были удалены и codechecker был перезапущен, то он не нашёл файлов The Boost Library самостоятельно и включил в анализ только мои файлы.

### Замечания к реальному коду

Первое из замечаний: "do not use namespace using-directives; use using-declaratins instead".

В моём коде:

```cpp
using namespace std;
```

Вероятно, Linter хочет, чтобы было написано более компактно:

```cpp
using std;
```

В следующем коде Linter посчитал разумным заменить тип на более однозначный. Было:

```cpp
long id = std::stol(strs[2]);
```

Предложено заменить **long** на **int64**.

Ещё одно замечание касалось добавление ключевого слова **explicit** к моему конструктору из класса CSVParser. Ключевое слово explicit должно запретить использование не явного преобразования типа при создании экземпляра класса.

Также Linter подсказал мне, что в классе CSVParser есть приватный член-класса, являющийся ссылкой:

```cpp
std::ifstream& m_File;
```

Допускаю, что более надёжным решением является использование умного указателя, вместо инициализации ссылки на поток.

В целом, найдены code smells, исправление которых позволит сделать код чище. Однако критичные ошибки в коде не были найдены.

Анализ описания проблем, найденных посредством Linter-ов, позволяет говорить о том, что набор Linter-ов в разных продуктах, в том числе в SonarLint, одинаковый, или пересекающийся.

## Альтенативы

Разработка Facebook - [Infer](https://fbinfer.com/) является статическим анализатором кода не только C/C++, но и Objective-C с Java.
